//=====================================================//
//  Copyright 2020, Analytical Graphics, Inc.          //
//=====================================================//
using AGI.Access.Constraint.Plugin;
using AGI.Attr;
using AGI.Plugin;
using Payload;
using System;
using System.Collections;
using System.Linq;
using System.Runtime.InteropServices;

namespace Stk12.AccessConstraint.ObjectDetection
{
	/// <summary>
	/// Company:    Analytical Graphics, Inc.
	/// Copyright:  None.  Modify and distribute at will
	///
	/// Description:
	/// 
	/// This constraint is registered only for Facilities/Targets when doing
	/// Access to a Sensor.
	///
	/// This constraint is purely an example of integrating a custom evauation metric into STK
	/// </summary>

	[Guid("cd5f50d0-ce2e-41a8-a24f-55151cb6f5df")]
    [ProgId("Stk12.AccessConstraint.ObjectDetection")]
	// NOTE: Specify the ClassInterfaceType.None enumeration, so the custom COM Interface 
	// you created, i.e. IParameters, is used instead of an autogenerated COM Interface.
	[ClassInterface(ClassInterfaceType.None)]
	public class ObjectDetection : 
		IParameters,
		IAgAccessConstraintPlugin,
		IAgUtPluginConfig
	{
		#region Data Members
		private string	m_DisplayName = "ObjectDetection";

		private IAgUtPluginSite  m_Site;
		private object			 m_Scope;	
		private Hashtable	     m_AxesHash = new Hashtable();

		// debug

		private bool			m_DebugMode;
		private int				m_MsgCntr;
		private int				m_MsgInterval;
		private double m_size;

		#endregion

		public ObjectDetection()
		{
			// defaults

			// Set a default object size
			m_size = 5;

			m_Site = null;
			m_Scope = null;


			m_DebugMode = false;	// NOTE: if true, will output a msg when
									// entering events other than Evaluate().
									//
									// DON'T set to true when using constraint as a
									// Figure of Merit,because PreCompute() and PostCompute()
									// are called once per animation step, which will cause
									// lots of messages to be written to the Message Viewer.
			m_MsgCntr = 0;
			m_MsgInterval = 100;
		}
		
		#region IAgAccessConstraintPlugin implementation

		public string DisplayName
		{
			get
			{
				return m_DisplayName;
			}
		}

		public void Register( AgAccessConstraintPluginResultRegister Result )
		{
			// Setup the receiver as the sensor
			Result.TargetDependency = (int)AgEAccessConstraintDependencyFlags.eDependencyNone;
			Result.BaseObjectType = AgEAccessConstraintObjectType.eSensor;
			Result.BaseDependency = (int)AgEAccessConstraintDependencyFlags.eDependencyRelativePosVel;
			Result.Dimension = "Unitless";
			Result.MinValue = 0.0;
			Result.MaxValue = 100.0;

			Result.AddTarget(AgEAccessConstraintObjectType.eTarget);
			Result.AddTarget(AgEAccessConstraintObjectType.eFacility);
			Result.AddTarget(AgEAccessConstraintObjectType.ePlace);
			Result.AddTarget(AgEAccessConstraintObjectType.eAircraft);
			Result.AddTarget(AgEAccessConstraintObjectType.eSatellite);
			Result.AddTarget(AgEAccessConstraintObjectType.eMissile);

			Result.Register();
			Result.Message(AGI.Plugin.AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName + ": Register Object Detection from Sensor to platforms");
		}

		public bool Init( IAgUtPluginSite site )
		{
			m_Site = site;
			
			if ( m_Site != null && m_DebugMode)
			{
				Message( AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName+": Init()" );
			}
			m_AxesHash.Clear();

			return true;
		}

		public bool PreCompute( AgAccessConstraintPluginResultPreCompute Result )
		{
			
			if( m_Site != null && m_DebugMode)
			{
				Message( AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName+": PreCompute()" );
			}

			return true;
		}

	
		public bool Evaluate( 
			AgAccessConstraintPluginResultEval Result, 
			AgAccessConstraintPluginObjectData baseObj, 
			AgAccessConstraintPluginObjectData targetObj )
		{
			if(Result != null)
			{
				Result.Value = 0.0;
			
				if( baseObj != null)
				{
					// Get the Relative position between objects					
					Array targetRelPositionArray = baseObj.RelativePosition_Array(AgEAccessApparentPositionType.eProperApparentPosition, AgEUtFrame.eUtFrameFixed);
					var targetRelPositionList = targetRelPositionArray.Cast<double>().ToList();
					
					// Capture the relative sun vector form the observer
					Array sunPositionArray = baseObj.ApparentSunPosition_Array(AgEUtFrame.eUtFrameFixed);
					var sunPositionList = sunPositionArray.Cast<double>().ToList();

					//Instantiate the external model
					ThePayload payload = new ThePayload
					{
						TargetCrossSection_SqMeters = TargetCrossSectionSqMeters
					};

					// Execute some portion of the external model at the current evaluation step
					//   with the mission information pulled from the scenario
					var detectability = payload.ComputeTargetDetectionProbability(
						targetRelPositionList[0], targetRelPositionList[1], targetRelPositionList[2],
						sunPositionList[0], sunPositionList[1], sunPositionList[2]);

					if (m_Site != null && m_DebugMode)
					{
						Message(AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName + " Detectability value: " + detectability.ToString());
					}

					Result.Value = Math.Min(detectability, 100);
				}
			}

			return true;
		}
		
		public bool PostCompute(AgAccessConstraintPluginResultPostCompute Result)
		{
			if( m_Site != null && m_DebugMode)
			{
				Message( AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName+": PostCompute()" );
			}
			return true;
		}

		public void Free()
		{
			if( m_Site != null && m_DebugMode)
			{
				Message( AgEUtLogMsgType.eUtLogMsgInfo, m_DisplayName+": Free()" );
			}

			m_Site = null;
		}
		
		#endregion

		#region IAgUtPluginConfig Interface Implementation
		public object GetPluginConfig( AgAttrBuilder aab )
		{
			try
			{
				if( this.m_Scope == null )
				{
					this.m_Scope = aab.NewScope();
				
					//===========================
					// Debug attributes
					//===========================
					aab.AddBoolDispatchProperty( this.m_Scope, "DebugMode", 
						"Turn debug messages on or off", 
						"DebugMode", 
						(int)AgEAttrAddFlags.eAddFlagNone );
				
					aab.AddIntDispatchProperty( this.m_Scope, "MessageInterval", 
						"The interval at which to send messages during propagation in Debug mode", 
						"MsgInterval", 
						(int)AgEAttrAddFlags.eAddFlagNone );

					aab.AddDoubleDispatchProperty(this.m_Scope, "TargetCrossSectionSqMeters",
						"The rough target cross section in m^2",
						"TargetCrossSectionSqMeters",
						(int)AgEAttrAddFlags.eAddFlagNone);

				}
			}
			finally
			{

			}
	
			return this.m_Scope;
		}

		public void VerifyPluginConfig( AgUtPluginConfigVerifyResult apcvr )
		{
			bool	result	= true;
			string	message = "Ok";

			if(m_size < 0.000001)
			{
				result = false;
				message = "Size is too small.";
			}
			
			apcvr.Result	= result;
			apcvr.Message	= message;
		}

#endregion

		#region IParameters Interface Implementation

        public double TargetCrossSectionSqMeters
		{
            get
            {
                return m_size;
            }
            set
            {
				m_size = value;
            }
        }

		public bool DebugMode
		{
			get
			{
				return this.m_DebugMode;
			}
			set
			{
				this.m_DebugMode = value;
			}
		}

		public int MsgInterval
		{
			get
			{
				return this.m_MsgInterval;
			}
			set
			{
				this.m_MsgInterval = value;
			}
		}

		#endregion

		#region Messaging Code

		private void Message (AgEUtLogMsgType severity, String msgStr)
		{
			if(  this.m_Site != null )
			{
				this.m_Site.Message( severity, msgStr);
			}
		}

		private void DebugMessage(String msgStr)
		{
			if(m_DebugMode)
			{
				if(m_MsgCntr % m_MsgInterval == 0)
				{
					Message(AgEUtLogMsgType.eUtLogMsgDebug, msgStr);
				}
			}
		}

		#endregion
	}
}
//=====================================================//
//  Copyright 2006, Analytical Graphics, Inc.          //
//=====================================================//